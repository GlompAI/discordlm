import { TextEngine } from "./TextEngine.ts";
import { Client, Guild, Message, TextChannel } from "discord.js";
import { replaceAllAsync } from "../replace.ts";
import { configService } from "./ConfigService.ts";
import { GifReader } from "npm:omggif";
import { PNG } from "npm:pngjs";
import { Buffer } from "node:buffer";
import { CharacterCard } from "../CharacterCard.ts";
import adze from "npm:adze";
import { dumpDebug } from "../debug.ts";
import { retrieve_url, search_web, tools } from "../tools.ts";
import { MessageView } from "../types.ts";
import { RESET_MESSAGE_CONTENT } from "../main.ts";

export class LLMService {
    private readonly textEngine: TextEngine;

    constructor() {
        this.textEngine = new TextEngine();
    }

    public async generateMessage(
        client: Client,
        messages: Message[],
        charId: string,
        character: CharacterCard | null,
        _seed?: number,
        continuation: { user: string; prompt: string } | false = false,
        sanitize = false,
    ) {
        async function convertSnowflake(userId: string, guild: Guild | null) {
            let returnString: string;
            if (guild) {
                try {
                    const clientUser = await guild.members.fetch(userId);
                    returnString = clientUser.nickname ?? clientUser.displayName;
                } catch {
                    try {
                        const clientUser = await client.users.fetch(userId);
                        returnString = clientUser.displayName;
                    } catch {
                        adze.error("An error occurred while trying to lookup some user.");
                    }
                    returnString = "Unknown User";
                }
            } else {
                const clientUser = await client.users.fetch(userId);
                returnString = clientUser.displayName;
            }
            return returnString;
        }

        function getCharacterName(message: Message): string | null {
            if (message.webhookId && (message as Message).author?.username) {
                return (message as Message).author.username;
            }
            if (message.author.bot && message.embeds.length > 0) {
                const embed = message.embeds[0];
                if (embed.title) {
                    return embed.title;
                }
            }
            return null;
        }

        const lastResetIndex = messages.map((m) => m.content).lastIndexOf(
            RESET_MESSAGE_CONTENT,
        );

        if (lastResetIndex !== -1) {
            messages = messages.slice(lastResetIndex + 1);
        }

        const history: MessageView[] = await Promise.all(
            messages.filter((m) => m.content || m.embeds.length > 0).map(async (message) => {
                let role: "user" | "assistant" | "system" = "user";
                let userName = "";
                let messageText = "";

                const characterName = getCharacterName(message);

                if (message.author.id === charId && !characterName) {
                    role = "assistant";
                    userName = "Assistant";
                    messageText = message.content;
                } else if (characterName) {
                    userName = characterName;
                    role = ((character?.name === characterName) || (character?.char_name === characterName))
                        ? "assistant"
                        : "user";

                    if (message.embeds.length > 0 && message.embeds[0].description) {
                        messageText = message.embeds[0].description;
                    } else {
                        messageText = message.content;
                    }
                } else {
                    role = "user";
                    userName = await convertSnowflake(message.author.id, message.guild);
                    messageText = sanitize ? message.cleanContent : message.content;
                }

                // Strip the attribution link from the message content
                messageText = messageText.replace(/\n\[Generated by .*?\]\(<https:\/\/discord\.com\/users\/\d+>\)/, "");

                let finalMessageText = await replaceAllAsync(
                    messageText,
                    /<@(\d+)>/g,
                    async (_, snowflake) => `@${await convertSnowflake(snowflake, message.guild)}`,
                );

                const mediaContent = [];

                if (message.attachments.size > 0) {
                    const attachmentMedia = await Promise.all(
                        message.attachments
                            .map(async (a) => {
                                if (!a.contentType?.startsWith("image/") && !a.contentType?.startsWith("video/")) {
                                    return null;
                                }

                                const response = await fetch(a.url);
                                const buffer = await response.arrayBuffer();

                                if (a.contentType === "image/gif") {
                                    try {
                                        const reader = new GifReader(Buffer.from(buffer));
                                        const png = new PNG({
                                            width: reader.width,
                                            height: reader.height,
                                        });
                                        const frameData = Buffer.alloc(reader.width * reader.height * 4);
                                        reader.decodeAndBlitFrameRGBA(0, frameData);
                                        png.data = frameData;
                                        const pngBuffer = PNG.sync.write(png);
                                        const base64 = btoa(String.fromCharCode(...pngBuffer));
                                        return {
                                            inlineData: {
                                                mimeType: "image/png",
                                                data: base64,
                                            },
                                        };
                                    } catch (error) {
                                        adze.error("Failed to process GIF attachment:", error);
                                        return null;
                                    }
                                } else {
                                    const bytes = new Uint8Array(buffer);
                                    let binary = "";
                                    for (let i = 0; i < bytes.byteLength; i++) {
                                        binary += String.fromCharCode(bytes[i]);
                                    }
                                    const base64 = btoa(binary);
                                    return {
                                        inlineData: {
                                            mimeType: a.contentType!,
                                            data: base64,
                                        },
                                    };
                                }
                            })
                            .filter(Boolean),
                    );
                    mediaContent.push(...attachmentMedia);
                }

                if (message.stickers.size > 0) {
                    const sticker = message.stickers.first()!;
                    if (finalMessageText.trim() === "") {
                        finalMessageText = `[sticker: ${sticker.name}]`;
                    } else {
                        finalMessageText += ` [sticker: ${sticker.name}]`;
                    }
                    const response = await fetch(sticker.url);
                    const blob = await response.blob();
                    const buffer = await blob.arrayBuffer();
                    const bytes = new Uint8Array(buffer);
                    let binary = "";
                    for (let i = 0; i < bytes.byteLength; i++) {
                        binary += String.fromCharCode(bytes[i]);
                    }
                    const base64 = btoa(binary);
                    mediaContent.push({
                        inlineData: {
                            mimeType: "image/png",
                            data: base64,
                        },
                    });
                }

                const emojiRegex = /<a?:(\w+):(\d+)>/g;
                const matches = [...finalMessageText.matchAll(emojiRegex)];
                for (const match of matches) {
                    const _emojiName = match[1];
                    const emojiId = match[2];
                    const isAnimated = match[0].startsWith("<a:");
                    const emojiUrl = `https://cdn.discordapp.com/emojis/${emojiId}.${isAnimated ? "gif" : "png"}`;
                    finalMessageText = finalMessageText.replace(match[0], "");

                    try {
                        const response = await fetch(emojiUrl);
                        if (!response.ok) continue;

                        const buffer = await response.arrayBuffer();

                        if (isAnimated) {
                            try {
                                const reader = new GifReader(Buffer.from(buffer));
                                const png = new PNG({
                                    width: reader.width,
                                    height: reader.height,
                                });
                                const frameData = Buffer.alloc(reader.width * reader.height * 4);
                                reader.decodeAndBlitFrameRGBA(0, frameData);
                                png.data = frameData;
                                const pngBuffer = PNG.sync.write(png);
                                const base64 = btoa(String.fromCharCode(...pngBuffer));
                                mediaContent.push({
                                    inlineData: {
                                        mimeType: "image/png",
                                        data: base64,
                                    },
                                });
                            } catch (error) {
                                adze.error(`Failed to process GIF emoji ${emojiUrl}:`, error);
                            }
                        } else {
                            const bytes = new Uint8Array(buffer);
                            let binary = "";
                            for (let i = 0; i < bytes.byteLength; i++) {
                                binary += String.fromCharCode(bytes[i]);
                            }
                            const base64 = btoa(binary);
                            mediaContent.push({
                                inlineData: {
                                    mimeType: "image/png",
                                    data: base64,
                                },
                            });
                        }
                    } catch (error) {
                        adze.error(`Failed to fetch emoji URL ${emojiUrl}:`, error);
                    }
                }

                return {
                    message: finalMessageText,
                    role,
                    messageId: message.id,
                    user: userName,
                    timestamp: message.createdAt.toISOString(),
                    mediaContent: mediaContent.length > 0 ? mediaContent : undefined,
                };
            }),
        );

        if (continuation) {
            history.push({
                role: "user",
                user: continuation.user,
                message: continuation.prompt,
                messageId: "",
                timestamp: new Date().toISOString(),
            });
        }
        const lastHumanMessage = history.slice().reverse().find((msg) => msg.role === "user");
        const username = lastHumanMessage?.user || "user";

        const prompt = this.textEngine.buildPrompt(history, username, character ?? undefined);
        const lastMessage = messages[messages.length - 1];
        const logContext = lastMessage.guild
            ? `[Guild: ${lastMessage.guild.name} | Channel: ${
                (lastMessage.channel as TextChannel).name
            } | User: ${lastMessage.author.tag}]`
            : `[DM from ${lastMessage.author.tag}]`;
        await dumpDebug(logContext, "prompt", prompt);

        const model = this.textEngine.client.getGenerativeModel({
            model: configService.getModel(),
            tools: [{ functionDeclarations: tools }],
            systemInstruction: prompt.systemInstruction,
            safetySettings: prompt.safetySettings,
        });

        const chat = model.startChat({
            history: prompt.history as any,
        });

        const result = await chat.sendMessage("");
        const response = result.response;
        const toolCalls = response.functionCalls();

        if (toolCalls) {
            for (const toolCall of toolCalls) {
                const functionName = toolCall.name;
                const args = toolCall.args as { [key: string]: string };
                let result = "";
                if (functionName === "search_web") {
                    result = await search_web(args.query);
                } else if (functionName === "retrieve_url") {
                    result = await retrieve_url(args.url);
                }
                history.push({
                    role: "function",
                    name: functionName,
                    message: result,
                    messageId: "",
                    timestamp: new Date().toISOString(),
                    user: "Tool",
                });
            }
            const finalPrompt = this.textEngine.buildPrompt(history, username, character ?? undefined);
            const finalChat = model.startChat({
                history: finalPrompt.history as any,
            });
            const finalResult = await finalChat.sendMessage("");
            return {
                completion: finalResult.response,
            };
        }

        return {
            completion: response,
        };
    }
}
